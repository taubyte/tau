package monkey_test

import (
	"context"
	"fmt"
	"io"
	"testing"
	"time"

	_ "github.com/taubyte/tau/clients/p2p/monkey/dream"
	"github.com/taubyte/tau/clients/p2p/patrick/mock"
	commonIface "github.com/taubyte/tau/core/common"
	iface "github.com/taubyte/tau/core/services/monkey"
	"github.com/taubyte/tau/core/services/patrick"
	"github.com/taubyte/tau/dream"
	"github.com/taubyte/tau/p2p/peer"
	protocolCommon "github.com/taubyte/tau/services/common"
	_ "github.com/taubyte/tau/services/hoarder/dream"
	"github.com/taubyte/tau/services/monkey"
	_ "github.com/taubyte/tau/services/monkey/dream"
	"gotest.tools/v3/assert"
)

func init() {
	monkey.NewPatrick = func(ctx context.Context, node peer.Node) (patrick.Client, error) {
		return &mock.Starfish{Jobs: make(map[string]*patrick.Job, 0)}, nil
	}
	protocolCommon.DefaultLockMinWaitTime = 50 * time.Millisecond
}

func TestService(t *testing.T) {
	u := dream.New(dream.UniverseConfig{Name: t.Name()})
	defer u.Stop()

	err := u.StartWithConfig(&dream.Config{
		Services: map[string]commonIface.ServiceConfig{
			"monkey":  {},
			"hoarder": {},
		},
		Simples: map[string]dream.SimpleConfig{
			"client": {
				Clients: dream.SimpleConfigClients{
					Monkey: &commonIface.ClientConfig{},
				}.Compat(),
			},
		},
	})
	if err != nil {
		t.Error(err)
		return
	}

	// Get simple client
	simple, err := u.Simple("client")
	if err != nil {
		t.Error(err)
		return
	}

	// Create and add successful job
	successful_job := &patrick.Job{
		Id:       "fake_jid_success",
		Logs:     make(map[string]string),
		AssetCid: make(map[string]string),
	}
	successful_job.Meta.Repository.ID = 1
	if err = u.Monkey().Patrick().(*mock.Starfish).AddJob(t, u.Monkey().Node(), successful_job); err != nil {
		t.Error(err)
		return
	}

	// Create and add failed job
	failed_job := &patrick.Job{
		Id:       "fake_jid_failed",
		Logs:     make(map[string]string),
		AssetCid: make(map[string]string),
	}
	failed_job.Meta.Repository.ID = 1
	if err = u.Monkey().Patrick().(*mock.Starfish).AddJob(t, u.Monkey().Node(), failed_job); err != nil {
		t.Error(err)
		return
	}

	// Test successful job
	monkey, err := simple.Monkey()
	assert.NilError(t, err)

	if err = (&MonkeyTestContext{
		universe:     u,
		client:       monkey,
		jid:          successful_job.Id,
		expectStatus: patrick.JobStatusSuccess,
		expectLog:    "Running job `fake_jid_success` was successful",
	}).waitForStatus(); err != nil {
		t.Error(err)
		return
	}

	// Test failed job
	if err = (&MonkeyTestContext{
		universe:     u,
		client:       monkey,
		jid:          failed_job.Id,
		expectStatus: patrick.JobStatusFailed,
		expectLog:    "Running job `fake_jid_failed` was successful",
	}).waitForStatus(); err != nil {
		t.Error(err)
		return
	}

	ids, err := monkey.List()
	if err != nil {
		t.Error(err)
		return
	}

	if len(ids) != 2 {
		t.Errorf("Expected two job ids got %d", len(ids))
		return
	}
}

type MonkeyTestContext struct {
	universe     *dream.Universe
	client       iface.Client
	jid          string
	expectStatus patrick.JobStatus
	expectLog    string
}

func (c *MonkeyTestContext) waitForStatus() error {
	test := func() error {
		response, err := c.client.Status(c.jid)
		if err != nil {
			return err
		}

		// Read logs
		err = readLogsTestHelper(c.universe.Context(), response, c.universe.Monkey().Node(), c.expectLog)
		if err != nil {
			return err
		}

		// Check status
		if response.Status != c.expectStatus {
			return fmt.Errorf("job was not successful `%v != %v`", response.Status, c.expectStatus)
		}

		return nil
	}

	attempts := 0
	maxAttempts := 3
	cont := func() {
		attempts += 1
		time.Sleep(time.Second)
	}

	// ==== Wait for job ====
	for {
		err := test()
		if err != nil && attempts >= maxAttempts {
			return fmt.Errorf("test failed after %d attempts with: %s", attempts, err.Error())
		} else if err == nil {
			break
		}
		cont()
	}

	return nil
}

func readLogsTestHelper(testCtx context.Context, response *iface.StatusResponse, peerC peer.Node, expected_logs string) error {
	cid_of_logs := response.Logs
	if len(cid_of_logs) == 0 {
		return fmt.Errorf("logs cid not found")
	}

	// Delete locally
	err := peerC.DeleteFile(cid_of_logs)
	if err != nil {
		return fmt.Errorf("Deleting logs `%s` failed with: %s", cid_of_logs, err.Error())
	}
	// Also checked with 15 second sleep
	time.Sleep(3 * time.Second)

	rs, err := peerC.GetFile(testCtx, cid_of_logs)
	if err != nil {
		return fmt.Errorf("Getting log filed failed with %s", err.Error())
	}
	// Read the logs
	logs, err := io.ReadAll(rs)
	if err != nil {
		return fmt.Errorf("Reading log file failed with %s", err.Error())
	}

	if expected_logs != string(logs) {
		return fmt.Errorf("Logs CID(`%s`)don't match, expected `%s` got `%s`", cid_of_logs, expected_logs, logs)
	}

	return nil
}
