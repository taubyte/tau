// @generated by protoc-gen-es v1.4.0 with parameter "target=ts"
// @generated from file config/v1/config.proto (package config.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from enum config.v1.BundleType
 */
export enum BundleType {
  /**
   * @generated from enum value: BUNDLE_ZIP = 0;
   */
  BUNDLE_ZIP = 0,

  /**
   * @generated from enum value: BUNDLE_TAR = 1;
   */
  BUNDLE_TAR = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(BundleType)
proto3.util.setEnumType(BundleType, "config.v1.BundleType", [
  { no: 0, name: "BUNDLE_ZIP" },
  { no: 1, name: "BUNDLE_TAR" },
]);

/**
 * @generated from message config.v1.Source
 */
export class Source extends Message<Source> {
  /**
   * @generated from field: string root = 1;
   */
  root = "";

  /**
   * @generated from field: string path = 2;
   */
  path = "";

  constructor(data?: PartialMessage<Source>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Source";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Source {
    return new Source().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Source {
    return new Source().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Source {
    return new Source().fromJsonString(jsonString, options);
  }

  static equals(a: Source | PlainMessage<Source> | undefined, b: Source | PlainMessage<Source> | undefined): boolean {
    return proto3.util.equals(Source, a, b);
  }
}

/**
 * @generated from message config.v1.SourceUpload
 */
export class SourceUpload extends Message<SourceUpload> {
  /**
   * @generated from oneof config.v1.SourceUpload.data
   */
  data: {
    /**
     * @generated from field: bytes chunk = 1;
     */
    value: Uint8Array;
    case: "chunk";
  } | {
    /**
     * @generated from field: string path = 2;
     */
    value: string;
    case: "path";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SourceUpload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.SourceUpload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "data" },
    { no: 2, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "data" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourceUpload {
    return new SourceUpload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourceUpload {
    return new SourceUpload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourceUpload {
    return new SourceUpload().fromJsonString(jsonString, options);
  }

  static equals(a: SourceUpload | PlainMessage<SourceUpload> | undefined, b: SourceUpload | PlainMessage<SourceUpload> | undefined): boolean {
    return proto3.util.equals(SourceUpload, a, b);
  }
}

/**
 * @generated from message config.v1.Config
 */
export class Config extends Message<Config> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<Config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Config {
    return new Config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Config {
    return new Config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Config {
    return new Config().fromJsonString(jsonString, options);
  }

  static equals(a: Config | PlainMessage<Config> | undefined, b: Config | PlainMessage<Config> | undefined): boolean {
    return proto3.util.equals(Config, a, b);
  }
}

/**
 * @generated from message config.v1.Bundle
 */
export class Bundle extends Message<Bundle> {
  /**
   * @generated from oneof config.v1.Bundle.data
   */
  data: {
    /**
     * @generated from field: config.v1.BundleType type = 1;
     */
    value: BundleType;
    case: "type";
  } | {
    /**
     * @generated from field: bytes chunk = 2;
     */
    value: Uint8Array;
    case: "chunk";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Bundle>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Bundle";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(BundleType), oneof: "data" },
    { no: 2, name: "chunk", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "data" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Bundle {
    return new Bundle().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Bundle {
    return new Bundle().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Bundle {
    return new Bundle().fromJsonString(jsonString, options);
  }

  static equals(a: Bundle | PlainMessage<Bundle> | undefined, b: Bundle | PlainMessage<Bundle> | undefined): boolean {
    return proto3.util.equals(Bundle, a, b);
  }
}

/**
 * @generated from message config.v1.StringOp
 */
export class StringOp extends Message<StringOp> {
  /**
   * @generated from oneof config.v1.StringOp.op
   */
  op: {
    /**
     * @generated from field: string set = 1;
     */
    value: string;
    case: "set";
  } | {
    /**
     * @generated from field: bool get = 2;
     */
    value: boolean;
    case: "get";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StringOp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.StringOp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "set", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "op" },
    { no: 2, name: "get", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringOp {
    return new StringOp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringOp {
    return new StringOp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringOp {
    return new StringOp().fromJsonString(jsonString, options);
  }

  static equals(a: StringOp | PlainMessage<StringOp> | undefined, b: StringOp | PlainMessage<StringOp> | undefined): boolean {
    return proto3.util.equals(StringOp, a, b);
  }
}

/**
 * @generated from message config.v1.BytesOp
 */
export class BytesOp extends Message<BytesOp> {
  /**
   * @generated from oneof config.v1.BytesOp.op
   */
  op: {
    /**
     * @generated from field: bytes set = 1;
     */
    value: Uint8Array;
    case: "set";
  } | {
    /**
     * @generated from field: bool get = 2;
     */
    value: boolean;
    case: "get";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<BytesOp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.BytesOp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "set", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "op" },
    { no: 2, name: "get", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesOp {
    return new BytesOp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesOp {
    return new BytesOp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesOp {
    return new BytesOp().fromJsonString(jsonString, options);
  }

  static equals(a: BytesOp | PlainMessage<BytesOp> | undefined, b: BytesOp | PlainMessage<BytesOp> | undefined): boolean {
    return proto3.util.equals(BytesOp, a, b);
  }
}

/**
 * @generated from message config.v1.StringSliceOp
 */
export class StringSliceOp extends Message<StringSliceOp> {
  /**
   * @generated from oneof config.v1.StringSliceOp.op
   */
  op: {
    /**
     * @generated from field: config.v1.StringSlice set = 1;
     */
    value: StringSlice;
    case: "set";
  } | {
    /**
     * @generated from field: config.v1.StringSlice add = 2;
     */
    value: StringSlice;
    case: "add";
  } | {
    /**
     * @generated from field: config.v1.StringSlice delete = 3;
     */
    value: StringSlice;
    case: "delete";
  } | {
    /**
     * @generated from field: bool clear = 4;
     */
    value: boolean;
    case: "clear";
  } | {
    /**
     * @generated from field: bool list = 5;
     */
    value: boolean;
    case: "list";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StringSliceOp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.StringSliceOp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "set", kind: "message", T: StringSlice, oneof: "op" },
    { no: 2, name: "add", kind: "message", T: StringSlice, oneof: "op" },
    { no: 3, name: "delete", kind: "message", T: StringSlice, oneof: "op" },
    { no: 4, name: "clear", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
    { no: 5, name: "list", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringSliceOp {
    return new StringSliceOp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringSliceOp {
    return new StringSliceOp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringSliceOp {
    return new StringSliceOp().fromJsonString(jsonString, options);
  }

  static equals(a: StringSliceOp | PlainMessage<StringSliceOp> | undefined, b: StringSliceOp | PlainMessage<StringSliceOp> | undefined): boolean {
    return proto3.util.equals(StringSliceOp, a, b);
  }
}

/**
 * @generated from message config.v1.ReturnValue
 */
export class ReturnValue extends Message<ReturnValue> {
  /**
   * @generated from oneof config.v1.ReturnValue.return
   */
  return: {
    /**
     * @generated from field: config.v1.StringOp value = 1;
     */
    value: StringOp;
    case: "value";
  } | {
    /**
     * @generated from field: config.v1.BytesOp data = 2;
     */
    value: BytesOp;
    case: "data";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ReturnValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.ReturnValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "message", T: StringOp, oneof: "return" },
    { no: 2, name: "data", kind: "message", T: BytesOp, oneof: "return" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReturnValue {
    return new ReturnValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReturnValue {
    return new ReturnValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReturnValue {
    return new ReturnValue().fromJsonString(jsonString, options);
  }

  static equals(a: ReturnValue | PlainMessage<ReturnValue> | undefined, b: ReturnValue | PlainMessage<ReturnValue> | undefined): boolean {
    return proto3.util.equals(ReturnValue, a, b);
  }
}

/**
 * @generated from message config.v1.StringSlice
 */
export class StringSlice extends Message<StringSlice> {
  /**
   * @generated from field: repeated string value = 1;
   */
  value: string[] = [];

  constructor(data?: PartialMessage<StringSlice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.StringSlice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringSlice {
    return new StringSlice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringSlice {
    return new StringSlice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringSlice {
    return new StringSlice().fromJsonString(jsonString, options);
  }

  static equals(a: StringSlice | PlainMessage<StringSlice> | undefined, b: StringSlice | PlainMessage<StringSlice> | undefined): boolean {
    return proto3.util.equals(StringSlice, a, b);
  }
}

/**
 * @generated from message config.v1.Error
 */
export class Error extends Message<Error> {
  /**
   * @generated from field: int64 code = 1;
   */
  code = protoInt64.zero;

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Error {
    return new Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJsonString(jsonString, options);
  }

  static equals(a: Error | PlainMessage<Error> | undefined, b: Error | PlainMessage<Error> | undefined): boolean {
    return proto3.util.equals(Error, a, b);
  }
}

/**
 * @generated from message config.v1.BundleConfig
 */
export class BundleConfig extends Message<BundleConfig> {
  /**
   * @generated from field: config.v1.Config id = 1;
   */
  id?: Config;

  /**
   * @generated from field: config.v1.BundleType type = 2;
   */
  type = BundleType.BUNDLE_ZIP;

  constructor(data?: PartialMessage<BundleConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.BundleConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: Config },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(BundleType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BundleConfig {
    return new BundleConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BundleConfig {
    return new BundleConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BundleConfig {
    return new BundleConfig().fromJsonString(jsonString, options);
  }

  static equals(a: BundleConfig | PlainMessage<BundleConfig> | undefined, b: BundleConfig | PlainMessage<BundleConfig> | undefined): boolean {
    return proto3.util.equals(BundleConfig, a, b);
  }
}

/**
 * @generated from message config.v1.Empty
 */
export class Empty extends Message<Empty> {
  constructor(data?: PartialMessage<Empty>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Empty";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Empty {
    return new Empty().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Empty {
    return new Empty().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Empty {
    return new Empty().fromJsonString(jsonString, options);
  }

  static equals(a: Empty | PlainMessage<Empty> | undefined, b: Empty | PlainMessage<Empty> | undefined): boolean {
    return proto3.util.equals(Empty, a, b);
  }
}

/**
 * Return
 *
 * @generated from message config.v1.Return
 */
export class Return extends Message<Return> {
  /**
   * @generated from oneof config.v1.Return.return
   */
  return: {
    /**
     * @generated from field: config.v1.Empty empty = 1;
     */
    value: Empty;
    case: "empty";
  } | {
    /**
     * @generated from field: string string = 2;
     */
    value: string;
    case: "string";
  } | {
    /**
     * @generated from field: config.v1.StringSlice slice = 3;
     */
    value: StringSlice;
    case: "slice";
  } | {
    /**
     * @generated from field: bytes bytes = 4;
     */
    value: Uint8Array;
    case: "bytes";
  } | {
    /**
     * @generated from field: uint64 uint64 = 5;
     */
    value: bigint;
    case: "uint64";
  } | {
    /**
     * @generated from field: int64 int64 = 6;
     */
    value: bigint;
    case: "int64";
  } | {
    /**
     * @generated from field: float float = 7;
     */
    value: number;
    case: "float";
  } | {
    /**
     * @generated from field: config.v1.Error error = 8;
     */
    value: Error;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Return>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Return";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "empty", kind: "message", T: Empty, oneof: "return" },
    { no: 2, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "return" },
    { no: 3, name: "slice", kind: "message", T: StringSlice, oneof: "return" },
    { no: 4, name: "bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "return" },
    { no: 5, name: "uint64", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "return" },
    { no: 6, name: "int64", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "return" },
    { no: 7, name: "float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, oneof: "return" },
    { no: 8, name: "error", kind: "message", T: Error, oneof: "return" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Return {
    return new Return().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Return {
    return new Return().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Return {
    return new Return().fromJsonString(jsonString, options);
  }

  static equals(a: Return | PlainMessage<Return> | undefined, b: Return | PlainMessage<Return> | undefined): boolean {
    return proto3.util.equals(Return, a, b);
  }
}

/**
 * Op
 *
 * @generated from message config.v1.Op
 */
export class Op extends Message<Op> {
  /**
   * @generated from field: config.v1.Config config = 1;
   */
  config?: Config;

  /**
   * @generated from oneof config.v1.Op.op
   */
  op: {
    /**
     * @generated from field: config.v1.Cloud cloud = 2;
     */
    value: Cloud;
    case: "cloud";
  } | {
    /**
     * @generated from field: config.v1.Hosts hosts = 3;
     */
    value: Hosts;
    case: "hosts";
  } | {
    /**
     * @generated from field: config.v1.Auth auth = 4;
     */
    value: Auth;
    case: "auth";
  } | {
    /**
     * @generated from field: config.v1.Shapes shapes = 5;
     */
    value: Shapes;
    case: "shapes";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Op>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Op";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: Config },
    { no: 2, name: "cloud", kind: "message", T: Cloud, oneof: "op" },
    { no: 3, name: "hosts", kind: "message", T: Hosts, oneof: "op" },
    { no: 4, name: "auth", kind: "message", T: Auth, oneof: "op" },
    { no: 5, name: "shapes", kind: "message", T: Shapes, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Op {
    return new Op().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Op {
    return new Op().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Op {
    return new Op().fromJsonString(jsonString, options);
  }

  static equals(a: Op | PlainMessage<Op> | undefined, b: Op | PlainMessage<Op> | undefined): boolean {
    return proto3.util.equals(Op, a, b);
  }
}

/**
 * Cloud
 *
 * @generated from message config.v1.Cloud
 */
export class Cloud extends Message<Cloud> {
  /**
   * @generated from oneof config.v1.Cloud.op
   */
  op: {
    /**
     * @generated from field: config.v1.Domain domain = 2;
     */
    value: Domain;
    case: "domain";
  } | {
    /**
     * @generated from field: config.v1.P2P p2p = 3;
     */
    value: P2P;
    case: "p2p";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Cloud>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Cloud";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "domain", kind: "message", T: Domain, oneof: "op" },
    { no: 3, name: "p2p", kind: "message", T: P2P, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cloud {
    return new Cloud().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cloud {
    return new Cloud().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cloud {
    return new Cloud().fromJsonString(jsonString, options);
  }

  static equals(a: Cloud | PlainMessage<Cloud> | undefined, b: Cloud | PlainMessage<Cloud> | undefined): boolean {
    return proto3.util.equals(Cloud, a, b);
  }
}

/**
 * @generated from message config.v1.Domain
 */
export class Domain extends Message<Domain> {
  /**
   * @generated from oneof config.v1.Domain.op
   */
  op: {
    /**
     * @generated from field: config.v1.StringOp root = 1;
     */
    value: StringOp;
    case: "root";
  } | {
    /**
     * @generated from field: config.v1.StringOp generated = 2;
     */
    value: StringOp;
    case: "generated";
  } | {
    /**
     * @generated from field: config.v1.Validation validation = 3;
     */
    value: Validation;
    case: "validation";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Domain>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Domain";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root", kind: "message", T: StringOp, oneof: "op" },
    { no: 2, name: "generated", kind: "message", T: StringOp, oneof: "op" },
    { no: 3, name: "validation", kind: "message", T: Validation, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Domain {
    return new Domain().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Domain {
    return new Domain().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Domain {
    return new Domain().fromJsonString(jsonString, options);
  }

  static equals(a: Domain | PlainMessage<Domain> | undefined, b: Domain | PlainMessage<Domain> | undefined): boolean {
    return proto3.util.equals(Domain, a, b);
  }
}

/**
 * @generated from message config.v1.Validation
 */
export class Validation extends Message<Validation> {
  /**
   * @generated from oneof config.v1.Validation.op
   */
  op: {
    /**
     * @generated from field: config.v1.ValidationKeys keys = 1;
     */
    value: ValidationKeys;
    case: "keys";
  } | {
    /**
     * @generated from field: bool generate = 2;
     */
    value: boolean;
    case: "generate";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Validation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Validation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "keys", kind: "message", T: ValidationKeys, oneof: "op" },
    { no: 2, name: "generate", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Validation {
    return new Validation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Validation {
    return new Validation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Validation {
    return new Validation().fromJsonString(jsonString, options);
  }

  static equals(a: Validation | PlainMessage<Validation> | undefined, b: Validation | PlainMessage<Validation> | undefined): boolean {
    return proto3.util.equals(Validation, a, b);
  }
}

/**
 * @generated from message config.v1.ValidationKeys
 */
export class ValidationKeys extends Message<ValidationKeys> {
  /**
   * @generated from oneof config.v1.ValidationKeys.op
   */
  op: {
    /**
     * @generated from field: config.v1.ValidationKeysPath path = 1;
     */
    value: ValidationKeysPath;
    case: "path";
  } | {
    /**
     * @generated from field: config.v1.ValidationKeysData data = 2;
     */
    value: ValidationKeysData;
    case: "data";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ValidationKeys>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.ValidationKeys";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "message", T: ValidationKeysPath, oneof: "op" },
    { no: 2, name: "data", kind: "message", T: ValidationKeysData, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidationKeys {
    return new ValidationKeys().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidationKeys {
    return new ValidationKeys().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidationKeys {
    return new ValidationKeys().fromJsonString(jsonString, options);
  }

  static equals(a: ValidationKeys | PlainMessage<ValidationKeys> | undefined, b: ValidationKeys | PlainMessage<ValidationKeys> | undefined): boolean {
    return proto3.util.equals(ValidationKeys, a, b);
  }
}

/**
 * @generated from message config.v1.ValidationKeysPath
 */
export class ValidationKeysPath extends Message<ValidationKeysPath> {
  /**
   * @generated from oneof config.v1.ValidationKeysPath.op
   */
  op: {
    /**
     * @generated from field: config.v1.StringOp private_key = 1;
     */
    value: StringOp;
    case: "privateKey";
  } | {
    /**
     * @generated from field: config.v1.StringOp public_key = 2;
     */
    value: StringOp;
    case: "publicKey";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ValidationKeysPath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.ValidationKeysPath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "private_key", kind: "message", T: StringOp, oneof: "op" },
    { no: 2, name: "public_key", kind: "message", T: StringOp, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidationKeysPath {
    return new ValidationKeysPath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidationKeysPath {
    return new ValidationKeysPath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidationKeysPath {
    return new ValidationKeysPath().fromJsonString(jsonString, options);
  }

  static equals(a: ValidationKeysPath | PlainMessage<ValidationKeysPath> | undefined, b: ValidationKeysPath | PlainMessage<ValidationKeysPath> | undefined): boolean {
    return proto3.util.equals(ValidationKeysPath, a, b);
  }
}

/**
 * @generated from message config.v1.ValidationKeysData
 */
export class ValidationKeysData extends Message<ValidationKeysData> {
  /**
   * @generated from oneof config.v1.ValidationKeysData.op
   */
  op: {
    /**
     * @generated from field: config.v1.BytesOp private_key = 1;
     */
    value: BytesOp;
    case: "privateKey";
  } | {
    /**
     * @generated from field: config.v1.BytesOp public_key = 2;
     */
    value: BytesOp;
    case: "publicKey";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ValidationKeysData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.ValidationKeysData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "private_key", kind: "message", T: BytesOp, oneof: "op" },
    { no: 2, name: "public_key", kind: "message", T: BytesOp, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidationKeysData {
    return new ValidationKeysData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidationKeysData {
    return new ValidationKeysData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidationKeysData {
    return new ValidationKeysData().fromJsonString(jsonString, options);
  }

  static equals(a: ValidationKeysData | PlainMessage<ValidationKeysData> | undefined, b: ValidationKeysData | PlainMessage<ValidationKeysData> | undefined): boolean {
    return proto3.util.equals(ValidationKeysData, a, b);
  }
}

/**
 * @generated from message config.v1.P2P
 */
export class P2P extends Message<P2P> {
  /**
   * @generated from oneof config.v1.P2P.op
   */
  op: {
    /**
     * @generated from field: config.v1.Bootstrap bootstrap = 1;
     */
    value: Bootstrap;
    case: "bootstrap";
  } | {
    /**
     * @generated from field: config.v1.Swarm swarm = 2;
     */
    value: Swarm;
    case: "swarm";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<P2P>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.P2P";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bootstrap", kind: "message", T: Bootstrap, oneof: "op" },
    { no: 2, name: "swarm", kind: "message", T: Swarm, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): P2P {
    return new P2P().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): P2P {
    return new P2P().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): P2P {
    return new P2P().fromJsonString(jsonString, options);
  }

  static equals(a: P2P | PlainMessage<P2P> | undefined, b: P2P | PlainMessage<P2P> | undefined): boolean {
    return proto3.util.equals(P2P, a, b);
  }
}

/**
 * @generated from message config.v1.Bootstrap
 */
export class Bootstrap extends Message<Bootstrap> {
  /**
   * @generated from oneof config.v1.Bootstrap.op
   */
  op: {
    /**
     * @generated from field: config.v1.BootstrapShape select = 1;
     */
    value: BootstrapShape;
    case: "select";
  } | {
    /**
     * @generated from field: bool list = 2;
     */
    value: boolean;
    case: "list";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Bootstrap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Bootstrap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "select", kind: "message", T: BootstrapShape, oneof: "op" },
    { no: 2, name: "list", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Bootstrap {
    return new Bootstrap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Bootstrap {
    return new Bootstrap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Bootstrap {
    return new Bootstrap().fromJsonString(jsonString, options);
  }

  static equals(a: Bootstrap | PlainMessage<Bootstrap> | undefined, b: Bootstrap | PlainMessage<Bootstrap> | undefined): boolean {
    return proto3.util.equals(Bootstrap, a, b);
  }
}

/**
 * @generated from message config.v1.BootstrapShape
 */
export class BootstrapShape extends Message<BootstrapShape> {
  /**
   * @generated from field: string shape = 1;
   */
  shape = "";

  /**
   * @generated from oneof config.v1.BootstrapShape.op
   */
  op: {
    /**
     * @generated from field: config.v1.StringSliceOp nodes = 2;
     */
    value: StringSliceOp;
    case: "nodes";
  } | {
    /**
     * @generated from field: bool delete = 3;
     */
    value: boolean;
    case: "delete";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<BootstrapShape>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.BootstrapShape";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "shape", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nodes", kind: "message", T: StringSliceOp, oneof: "op" },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BootstrapShape {
    return new BootstrapShape().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BootstrapShape {
    return new BootstrapShape().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BootstrapShape {
    return new BootstrapShape().fromJsonString(jsonString, options);
  }

  static equals(a: BootstrapShape | PlainMessage<BootstrapShape> | undefined, b: BootstrapShape | PlainMessage<BootstrapShape> | undefined): boolean {
    return proto3.util.equals(BootstrapShape, a, b);
  }
}

/**
 * @generated from message config.v1.Swarm
 */
export class Swarm extends Message<Swarm> {
  /**
   * @generated from oneof config.v1.Swarm.op
   */
  op: {
    /**
     * @generated from field: config.v1.SwarmKey key = 1;
     */
    value: SwarmKey;
    case: "key";
  } | {
    /**
     * @generated from field: bool generate = 2;
     */
    value: boolean;
    case: "generate";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Swarm>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Swarm";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: SwarmKey, oneof: "op" },
    { no: 2, name: "generate", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Swarm {
    return new Swarm().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Swarm {
    return new Swarm().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Swarm {
    return new Swarm().fromJsonString(jsonString, options);
  }

  static equals(a: Swarm | PlainMessage<Swarm> | undefined, b: Swarm | PlainMessage<Swarm> | undefined): boolean {
    return proto3.util.equals(Swarm, a, b);
  }
}

/**
 * @generated from message config.v1.SwarmKey
 */
export class SwarmKey extends Message<SwarmKey> {
  /**
   * @generated from oneof config.v1.SwarmKey.op
   */
  op: {
    /**
     * @generated from field: config.v1.StringOp path = 1;
     */
    value: StringOp;
    case: "path";
  } | {
    /**
     * @generated from field: config.v1.BytesOp data = 2;
     */
    value: BytesOp;
    case: "data";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SwarmKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.SwarmKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "message", T: StringOp, oneof: "op" },
    { no: 2, name: "data", kind: "message", T: BytesOp, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwarmKey {
    return new SwarmKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwarmKey {
    return new SwarmKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwarmKey {
    return new SwarmKey().fromJsonString(jsonString, options);
  }

  static equals(a: SwarmKey | PlainMessage<SwarmKey> | undefined, b: SwarmKey | PlainMessage<SwarmKey> | undefined): boolean {
    return proto3.util.equals(SwarmKey, a, b);
  }
}

/**
 * Hosts
 *
 * @generated from message config.v1.Hosts
 */
export class Hosts extends Message<Hosts> {
  /**
   * @generated from oneof config.v1.Hosts.op
   */
  op: {
    /**
     * @generated from field: config.v1.Host select = 1;
     */
    value: Host;
    case: "select";
  } | {
    /**
     * @generated from field: bool list = 2;
     */
    value: boolean;
    case: "list";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Hosts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Hosts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "select", kind: "message", T: Host, oneof: "op" },
    { no: 2, name: "list", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Hosts {
    return new Hosts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Hosts {
    return new Hosts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Hosts {
    return new Hosts().fromJsonString(jsonString, options);
  }

  static equals(a: Hosts | PlainMessage<Hosts> | undefined, b: Hosts | PlainMessage<Hosts> | undefined): boolean {
    return proto3.util.equals(Hosts, a, b);
  }
}

/**
 * @generated from message config.v1.Host
 */
export class Host extends Message<Host> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from oneof config.v1.Host.op
   */
  op: {
    /**
     * @generated from field: config.v1.StringSliceOp addresses = 2;
     */
    value: StringSliceOp;
    case: "addresses";
  } | {
    /**
     * @generated from field: config.v1.SSH ssh = 3;
     */
    value: SSH;
    case: "ssh";
  } | {
    /**
     * comma separated
     *
     * @generated from field: config.v1.StringOp location = 4;
     */
    value: StringOp;
    case: "location";
  } | {
    /**
     * @generated from field: config.v1.HostShapes shapes = 5;
     */
    value: HostShapes;
    case: "shapes";
  } | {
    /**
     * @generated from field: bool delete = 6;
     */
    value: boolean;
    case: "delete";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Host>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Host";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "addresses", kind: "message", T: StringSliceOp, oneof: "op" },
    { no: 3, name: "ssh", kind: "message", T: SSH, oneof: "op" },
    { no: 4, name: "location", kind: "message", T: StringOp, oneof: "op" },
    { no: 5, name: "shapes", kind: "message", T: HostShapes, oneof: "op" },
    { no: 6, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Host {
    return new Host().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Host {
    return new Host().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Host {
    return new Host().fromJsonString(jsonString, options);
  }

  static equals(a: Host | PlainMessage<Host> | undefined, b: Host | PlainMessage<Host> | undefined): boolean {
    return proto3.util.equals(Host, a, b);
  }
}

/**
 * @generated from message config.v1.SSH
 */
export class SSH extends Message<SSH> {
  /**
   * @generated from oneof config.v1.SSH.op
   */
  op: {
    /**
     * addr:port
     *
     * @generated from field: config.v1.StringOp address = 1;
     */
    value: StringOp;
    case: "address";
  } | {
    /**
     * @generated from field: config.v1.StringSliceOp auth = 2;
     */
    value: StringSliceOp;
    case: "auth";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SSH>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.SSH";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "message", T: StringOp, oneof: "op" },
    { no: 2, name: "auth", kind: "message", T: StringSliceOp, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SSH {
    return new SSH().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SSH {
    return new SSH().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SSH {
    return new SSH().fromJsonString(jsonString, options);
  }

  static equals(a: SSH | PlainMessage<SSH> | undefined, b: SSH | PlainMessage<SSH> | undefined): boolean {
    return proto3.util.equals(SSH, a, b);
  }
}

/**
 * @generated from message config.v1.HostShapes
 */
export class HostShapes extends Message<HostShapes> {
  /**
   * @generated from oneof config.v1.HostShapes.op
   */
  op: {
    /**
     * @generated from field: config.v1.HostShape select = 1;
     */
    value: HostShape;
    case: "select";
  } | {
    /**
     * @generated from field: bool list = 2;
     */
    value: boolean;
    case: "list";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<HostShapes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.HostShapes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "select", kind: "message", T: HostShape, oneof: "op" },
    { no: 2, name: "list", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HostShapes {
    return new HostShapes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HostShapes {
    return new HostShapes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HostShapes {
    return new HostShapes().fromJsonString(jsonString, options);
  }

  static equals(a: HostShapes | PlainMessage<HostShapes> | undefined, b: HostShapes | PlainMessage<HostShapes> | undefined): boolean {
    return proto3.util.equals(HostShapes, a, b);
  }
}

/**
 * @generated from message config.v1.HostShape
 */
export class HostShape extends Message<HostShape> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from oneof config.v1.HostShape.op
   */
  op: {
    /**
     * @generated from field: config.v1.HostInstance select = 2;
     */
    value: HostInstance;
    case: "select";
  } | {
    /**
     * @generated from field: bool delete = 3;
     */
    value: boolean;
    case: "delete";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<HostShape>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.HostShape";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "select", kind: "message", T: HostInstance, oneof: "op" },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HostShape {
    return new HostShape().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HostShape {
    return new HostShape().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HostShape {
    return new HostShape().fromJsonString(jsonString, options);
  }

  static equals(a: HostShape | PlainMessage<HostShape> | undefined, b: HostShape | PlainMessage<HostShape> | undefined): boolean {
    return proto3.util.equals(HostShape, a, b);
  }
}

/**
 * @generated from message config.v1.HostInstance
 */
export class HostInstance extends Message<HostInstance> {
  /**
   * @generated from oneof config.v1.HostInstance.op
   */
  op: {
    /**
     * @generated from field: bool id = 1;
     */
    value: boolean;
    case: "id";
  } | {
    /**
     * @generated from field: config.v1.StringOp key = 2;
     */
    value: StringOp;
    case: "key";
  } | {
    /**
     * @generated from field: bool generate = 3;
     */
    value: boolean;
    case: "generate";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<HostInstance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.HostInstance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
    { no: 2, name: "key", kind: "message", T: StringOp, oneof: "op" },
    { no: 3, name: "generate", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HostInstance {
    return new HostInstance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HostInstance {
    return new HostInstance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HostInstance {
    return new HostInstance().fromJsonString(jsonString, options);
  }

  static equals(a: HostInstance | PlainMessage<HostInstance> | undefined, b: HostInstance | PlainMessage<HostInstance> | undefined): boolean {
    return proto3.util.equals(HostInstance, a, b);
  }
}

/**
 * Auth
 *
 * @generated from message config.v1.Auth
 */
export class Auth extends Message<Auth> {
  /**
   * @generated from oneof config.v1.Auth.op
   */
  op: {
    /**
     * @generated from field: config.v1.Signer select = 1;
     */
    value: Signer;
    case: "select";
  } | {
    /**
     * @generated from field: bool list = 2;
     */
    value: boolean;
    case: "list";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Auth>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Auth";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "select", kind: "message", T: Signer, oneof: "op" },
    { no: 2, name: "list", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Auth {
    return new Auth().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Auth {
    return new Auth().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Auth {
    return new Auth().fromJsonString(jsonString, options);
  }

  static equals(a: Auth | PlainMessage<Auth> | undefined, b: Auth | PlainMessage<Auth> | undefined): boolean {
    return proto3.util.equals(Auth, a, b);
  }
}

/**
 * @generated from message config.v1.Signer
 */
export class Signer extends Message<Signer> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from oneof config.v1.Signer.op
   */
  op: {
    /**
     * @generated from field: config.v1.StringOp username = 2;
     */
    value: StringOp;
    case: "username";
  } | {
    /**
     * @generated from field: config.v1.StringOp password = 3;
     */
    value: StringOp;
    case: "password";
  } | {
    /**
     * @generated from field: config.v1.SSHKey key = 4;
     */
    value: SSHKey;
    case: "key";
  } | {
    /**
     * @generated from field: bool delete = 5;
     */
    value: boolean;
    case: "delete";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Signer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Signer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "username", kind: "message", T: StringOp, oneof: "op" },
    { no: 3, name: "password", kind: "message", T: StringOp, oneof: "op" },
    { no: 4, name: "key", kind: "message", T: SSHKey, oneof: "op" },
    { no: 5, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Signer {
    return new Signer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Signer {
    return new Signer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Signer {
    return new Signer().fromJsonString(jsonString, options);
  }

  static equals(a: Signer | PlainMessage<Signer> | undefined, b: Signer | PlainMessage<Signer> | undefined): boolean {
    return proto3.util.equals(Signer, a, b);
  }
}

/**
 * @generated from message config.v1.SSHKey
 */
export class SSHKey extends Message<SSHKey> {
  /**
   * @generated from oneof config.v1.SSHKey.op
   */
  op: {
    /**
     * @generated from field: config.v1.StringOp path = 1;
     */
    value: StringOp;
    case: "path";
  } | {
    /**
     * @generated from field: config.v1.BytesOp data = 2;
     */
    value: BytesOp;
    case: "data";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SSHKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.SSHKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "message", T: StringOp, oneof: "op" },
    { no: 2, name: "data", kind: "message", T: BytesOp, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SSHKey {
    return new SSHKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SSHKey {
    return new SSHKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SSHKey {
    return new SSHKey().fromJsonString(jsonString, options);
  }

  static equals(a: SSHKey | PlainMessage<SSHKey> | undefined, b: SSHKey | PlainMessage<SSHKey> | undefined): boolean {
    return proto3.util.equals(SSHKey, a, b);
  }
}

/**
 * Shapes
 *
 * @generated from message config.v1.Shapes
 */
export class Shapes extends Message<Shapes> {
  /**
   * @generated from oneof config.v1.Shapes.op
   */
  op: {
    /**
     * @generated from field: config.v1.Shape select = 1;
     */
    value: Shape;
    case: "select";
  } | {
    /**
     * @generated from field: bool list = 2;
     */
    value: boolean;
    case: "list";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Shapes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Shapes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "select", kind: "message", T: Shape, oneof: "op" },
    { no: 2, name: "list", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Shapes {
    return new Shapes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Shapes {
    return new Shapes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Shapes {
    return new Shapes().fromJsonString(jsonString, options);
  }

  static equals(a: Shapes | PlainMessage<Shapes> | undefined, b: Shapes | PlainMessage<Shapes> | undefined): boolean {
    return proto3.util.equals(Shapes, a, b);
  }
}

/**
 * @generated from message config.v1.Shape
 */
export class Shape extends Message<Shape> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from oneof config.v1.Shape.op
   */
  op: {
    /**
     * @generated from field: config.v1.StringSliceOp services = 2;
     */
    value: StringSliceOp;
    case: "services";
  } | {
    /**
     * @generated from field: config.v1.Ports ports = 3;
     */
    value: Ports;
    case: "ports";
  } | {
    /**
     * @generated from field: config.v1.StringSliceOp plugins = 4;
     */
    value: StringSliceOp;
    case: "plugins";
  } | {
    /**
     * @generated from field: bool delete = 5;
     */
    value: boolean;
    case: "delete";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Shape>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Shape";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "services", kind: "message", T: StringSliceOp, oneof: "op" },
    { no: 3, name: "ports", kind: "message", T: Ports, oneof: "op" },
    { no: 4, name: "plugins", kind: "message", T: StringSliceOp, oneof: "op" },
    { no: 5, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Shape {
    return new Shape().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Shape {
    return new Shape().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Shape {
    return new Shape().fromJsonString(jsonString, options);
  }

  static equals(a: Shape | PlainMessage<Shape> | undefined, b: Shape | PlainMessage<Shape> | undefined): boolean {
    return proto3.util.equals(Shape, a, b);
  }
}

/**
 * @generated from message config.v1.Ports
 */
export class Ports extends Message<Ports> {
  /**
   * @generated from oneof config.v1.Ports.op
   */
  op: {
    /**
     * @generated from field: config.v1.Port select = 1;
     */
    value: Port;
    case: "select";
  } | {
    /**
     * @generated from field: bool list = 2;
     */
    value: boolean;
    case: "list";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Ports>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Ports";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "select", kind: "message", T: Port, oneof: "op" },
    { no: 2, name: "list", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ports {
    return new Ports().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ports {
    return new Ports().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ports {
    return new Ports().fromJsonString(jsonString, options);
  }

  static equals(a: Ports | PlainMessage<Ports> | undefined, b: Ports | PlainMessage<Ports> | undefined): boolean {
    return proto3.util.equals(Ports, a, b);
  }
}

/**
 * @generated from message config.v1.Port
 */
export class Port extends Message<Port> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from oneof config.v1.Port.op
   */
  op: {
    /**
     * @generated from field: uint64 set = 2;
     */
    value: bigint;
    case: "set";
  } | {
    /**
     * @generated from field: bool get = 3;
     */
    value: boolean;
    case: "get";
  } | {
    /**
     * @generated from field: bool delete = 4;
     */
    value: boolean;
    case: "delete";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Port>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.Port";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "set", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "op" },
    { no: 3, name: "get", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
    { no: 4, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Port {
    return new Port().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Port {
    return new Port().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Port {
    return new Port().fromJsonString(jsonString, options);
  }

  static equals(a: Port | PlainMessage<Port> | undefined, b: Port | PlainMessage<Port> | undefined): boolean {
    return proto3.util.equals(Port, a, b);
  }
}

