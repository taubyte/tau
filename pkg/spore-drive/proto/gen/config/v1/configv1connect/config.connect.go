// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: config/v1/config.proto

package configv1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/taubyte/tau/pkg/spore-drive/proto/gen/config/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// ConfigServiceName is the fully-qualified name of the ConfigService service.
	ConfigServiceName = "config.v1.ConfigService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// ConfigServiceNewProcedure is the fully-qualified name of the ConfigService's New RPC.
	ConfigServiceNewProcedure = "/config.v1.ConfigService/New"
	// ConfigServiceLoadProcedure is the fully-qualified name of the ConfigService's Load RPC.
	ConfigServiceLoadProcedure = "/config.v1.ConfigService/Load"
	// ConfigServiceUploadProcedure is the fully-qualified name of the ConfigService's Upload RPC.
	ConfigServiceUploadProcedure = "/config.v1.ConfigService/Upload"
	// ConfigServiceDownloadProcedure is the fully-qualified name of the ConfigService's Download RPC.
	ConfigServiceDownloadProcedure = "/config.v1.ConfigService/Download"
	// ConfigServiceCommitProcedure is the fully-qualified name of the ConfigService's Commit RPC.
	ConfigServiceCommitProcedure = "/config.v1.ConfigService/Commit"
	// ConfigServiceFreeProcedure is the fully-qualified name of the ConfigService's Free RPC.
	ConfigServiceFreeProcedure = "/config.v1.ConfigService/Free"
	// ConfigServiceDoProcedure is the fully-qualified name of the ConfigService's Do RPC.
	ConfigServiceDoProcedure = "/config.v1.ConfigService/Do"
)

// These variables are the protoreflect.Descriptor objects for the RPCs defined in this package.
var (
	configServiceServiceDescriptor        = v1.File_config_v1_config_proto.Services().ByName("ConfigService")
	configServiceNewMethodDescriptor      = configServiceServiceDescriptor.Methods().ByName("New")
	configServiceLoadMethodDescriptor     = configServiceServiceDescriptor.Methods().ByName("Load")
	configServiceUploadMethodDescriptor   = configServiceServiceDescriptor.Methods().ByName("Upload")
	configServiceDownloadMethodDescriptor = configServiceServiceDescriptor.Methods().ByName("Download")
	configServiceCommitMethodDescriptor   = configServiceServiceDescriptor.Methods().ByName("Commit")
	configServiceFreeMethodDescriptor     = configServiceServiceDescriptor.Methods().ByName("Free")
	configServiceDoMethodDescriptor       = configServiceServiceDescriptor.Methods().ByName("Do")
)

// ConfigServiceClient is a client for the config.v1.ConfigService service.
type ConfigServiceClient interface {
	New(context.Context, *connect.Request[v1.Empty]) (*connect.Response[v1.Config], error)
	Load(context.Context, *connect.Request[v1.Source]) (*connect.Response[v1.Config], error)
	Upload(context.Context) *connect.ClientStreamForClient[v1.SourceUpload, v1.Config]
	Download(context.Context, *connect.Request[v1.BundleConfig]) (*connect.ServerStreamForClient[v1.Bundle], error)
	Commit(context.Context, *connect.Request[v1.Config]) (*connect.Response[v1.Empty], error)
	Free(context.Context, *connect.Request[v1.Config]) (*connect.Response[v1.Empty], error)
	Do(context.Context, *connect.Request[v1.Op]) (*connect.Response[v1.Return], error)
}

// NewConfigServiceClient constructs a client for the config.v1.ConfigService service. By default,
// it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and
// sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC()
// or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewConfigServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) ConfigServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &configServiceClient{
		new: connect.NewClient[v1.Empty, v1.Config](
			httpClient,
			baseURL+ConfigServiceNewProcedure,
			connect.WithSchema(configServiceNewMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		load: connect.NewClient[v1.Source, v1.Config](
			httpClient,
			baseURL+ConfigServiceLoadProcedure,
			connect.WithSchema(configServiceLoadMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		upload: connect.NewClient[v1.SourceUpload, v1.Config](
			httpClient,
			baseURL+ConfigServiceUploadProcedure,
			connect.WithSchema(configServiceUploadMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		download: connect.NewClient[v1.BundleConfig, v1.Bundle](
			httpClient,
			baseURL+ConfigServiceDownloadProcedure,
			connect.WithSchema(configServiceDownloadMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		commit: connect.NewClient[v1.Config, v1.Empty](
			httpClient,
			baseURL+ConfigServiceCommitProcedure,
			connect.WithSchema(configServiceCommitMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		free: connect.NewClient[v1.Config, v1.Empty](
			httpClient,
			baseURL+ConfigServiceFreeProcedure,
			connect.WithSchema(configServiceFreeMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		do: connect.NewClient[v1.Op, v1.Return](
			httpClient,
			baseURL+ConfigServiceDoProcedure,
			connect.WithSchema(configServiceDoMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// configServiceClient implements ConfigServiceClient.
type configServiceClient struct {
	new      *connect.Client[v1.Empty, v1.Config]
	load     *connect.Client[v1.Source, v1.Config]
	upload   *connect.Client[v1.SourceUpload, v1.Config]
	download *connect.Client[v1.BundleConfig, v1.Bundle]
	commit   *connect.Client[v1.Config, v1.Empty]
	free     *connect.Client[v1.Config, v1.Empty]
	do       *connect.Client[v1.Op, v1.Return]
}

// New calls config.v1.ConfigService.New.
func (c *configServiceClient) New(ctx context.Context, req *connect.Request[v1.Empty]) (*connect.Response[v1.Config], error) {
	return c.new.CallUnary(ctx, req)
}

// Load calls config.v1.ConfigService.Load.
func (c *configServiceClient) Load(ctx context.Context, req *connect.Request[v1.Source]) (*connect.Response[v1.Config], error) {
	return c.load.CallUnary(ctx, req)
}

// Upload calls config.v1.ConfigService.Upload.
func (c *configServiceClient) Upload(ctx context.Context) *connect.ClientStreamForClient[v1.SourceUpload, v1.Config] {
	return c.upload.CallClientStream(ctx)
}

// Download calls config.v1.ConfigService.Download.
func (c *configServiceClient) Download(ctx context.Context, req *connect.Request[v1.BundleConfig]) (*connect.ServerStreamForClient[v1.Bundle], error) {
	return c.download.CallServerStream(ctx, req)
}

// Commit calls config.v1.ConfigService.Commit.
func (c *configServiceClient) Commit(ctx context.Context, req *connect.Request[v1.Config]) (*connect.Response[v1.Empty], error) {
	return c.commit.CallUnary(ctx, req)
}

// Free calls config.v1.ConfigService.Free.
func (c *configServiceClient) Free(ctx context.Context, req *connect.Request[v1.Config]) (*connect.Response[v1.Empty], error) {
	return c.free.CallUnary(ctx, req)
}

// Do calls config.v1.ConfigService.Do.
func (c *configServiceClient) Do(ctx context.Context, req *connect.Request[v1.Op]) (*connect.Response[v1.Return], error) {
	return c.do.CallUnary(ctx, req)
}

// ConfigServiceHandler is an implementation of the config.v1.ConfigService service.
type ConfigServiceHandler interface {
	New(context.Context, *connect.Request[v1.Empty]) (*connect.Response[v1.Config], error)
	Load(context.Context, *connect.Request[v1.Source]) (*connect.Response[v1.Config], error)
	Upload(context.Context, *connect.ClientStream[v1.SourceUpload]) (*connect.Response[v1.Config], error)
	Download(context.Context, *connect.Request[v1.BundleConfig], *connect.ServerStream[v1.Bundle]) error
	Commit(context.Context, *connect.Request[v1.Config]) (*connect.Response[v1.Empty], error)
	Free(context.Context, *connect.Request[v1.Config]) (*connect.Response[v1.Empty], error)
	Do(context.Context, *connect.Request[v1.Op]) (*connect.Response[v1.Return], error)
}

// NewConfigServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewConfigServiceHandler(svc ConfigServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	configServiceNewHandler := connect.NewUnaryHandler(
		ConfigServiceNewProcedure,
		svc.New,
		connect.WithSchema(configServiceNewMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	configServiceLoadHandler := connect.NewUnaryHandler(
		ConfigServiceLoadProcedure,
		svc.Load,
		connect.WithSchema(configServiceLoadMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	configServiceUploadHandler := connect.NewClientStreamHandler(
		ConfigServiceUploadProcedure,
		svc.Upload,
		connect.WithSchema(configServiceUploadMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	configServiceDownloadHandler := connect.NewServerStreamHandler(
		ConfigServiceDownloadProcedure,
		svc.Download,
		connect.WithSchema(configServiceDownloadMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	configServiceCommitHandler := connect.NewUnaryHandler(
		ConfigServiceCommitProcedure,
		svc.Commit,
		connect.WithSchema(configServiceCommitMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	configServiceFreeHandler := connect.NewUnaryHandler(
		ConfigServiceFreeProcedure,
		svc.Free,
		connect.WithSchema(configServiceFreeMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	configServiceDoHandler := connect.NewUnaryHandler(
		ConfigServiceDoProcedure,
		svc.Do,
		connect.WithSchema(configServiceDoMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/config.v1.ConfigService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case ConfigServiceNewProcedure:
			configServiceNewHandler.ServeHTTP(w, r)
		case ConfigServiceLoadProcedure:
			configServiceLoadHandler.ServeHTTP(w, r)
		case ConfigServiceUploadProcedure:
			configServiceUploadHandler.ServeHTTP(w, r)
		case ConfigServiceDownloadProcedure:
			configServiceDownloadHandler.ServeHTTP(w, r)
		case ConfigServiceCommitProcedure:
			configServiceCommitHandler.ServeHTTP(w, r)
		case ConfigServiceFreeProcedure:
			configServiceFreeHandler.ServeHTTP(w, r)
		case ConfigServiceDoProcedure:
			configServiceDoHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedConfigServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedConfigServiceHandler struct{}

func (UnimplementedConfigServiceHandler) New(context.Context, *connect.Request[v1.Empty]) (*connect.Response[v1.Config], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("config.v1.ConfigService.New is not implemented"))
}

func (UnimplementedConfigServiceHandler) Load(context.Context, *connect.Request[v1.Source]) (*connect.Response[v1.Config], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("config.v1.ConfigService.Load is not implemented"))
}

func (UnimplementedConfigServiceHandler) Upload(context.Context, *connect.ClientStream[v1.SourceUpload]) (*connect.Response[v1.Config], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("config.v1.ConfigService.Upload is not implemented"))
}

func (UnimplementedConfigServiceHandler) Download(context.Context, *connect.Request[v1.BundleConfig], *connect.ServerStream[v1.Bundle]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("config.v1.ConfigService.Download is not implemented"))
}

func (UnimplementedConfigServiceHandler) Commit(context.Context, *connect.Request[v1.Config]) (*connect.Response[v1.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("config.v1.ConfigService.Commit is not implemented"))
}

func (UnimplementedConfigServiceHandler) Free(context.Context, *connect.Request[v1.Config]) (*connect.Response[v1.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("config.v1.ConfigService.Free is not implemented"))
}

func (UnimplementedConfigServiceHandler) Do(context.Context, *connect.Request[v1.Op]) (*connect.Response[v1.Return], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("config.v1.ConfigService.Do is not implemented"))
}
